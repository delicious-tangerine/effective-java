# Item 28 : 배열보다는 리스트를 사용하라

> 💡 배열은 제네릭에 적합하지 않다.
> 
> → 런타임에는 타입 안전하지만, 컴파일 타임에는 그렇지 않다.

### 배열과 제네릭의 차이 
- 배열은 호환되지 않는 타입을 런타임에 알게 되지만, 제네릭은 컴파일 타임에 알 수 있다.
- 배열은 런타임에도 원소의 타입을 인지하고 확인하지만, 제네릭은 타입정보가 런타임에서는 소거되기 때문에 알 수 없다.

위와 같은 이유로 제네릭 배열은 생성되지 않는다. => 타입 안전하지 않기 때문에 제네릭의 취지에 어긋난다.

<br>

### 리스트를 사용하자
코드가 복잡해지고 성능이 살짝 나빠질 수 있지만,

타입안전성과 상호운용성이 좋아진다.

어떻게든 제네릭과 배열을 함께 쓰기 위해 형변환을 하는 등의 작업을 통해 가능하지만

비교적 안전성이 떨어지게 된다.


<br>

### 꼭 배열을 반환해야 겠다
뒤의 아이템에서 확인해라

### 타입 소거 과정
- 제네릭 타입( Example<T>) 에서는 해당하는 타입 파라미터 (T) 나 Object로 변경해준다.
  
  Object로 변경하는 경우는 unbounded 된 경우를 뜻하며, 이는 <E extends Comparable<E>>와 같이 bound를 해주지 않은 경우를 의미한다.
  
  따라서 이 소거 규칙에 대한 바이트코드는 제네릭을 적용할 수 있는 일반 클래스, 인터페이스, 메서드에만 해당된다.
- 타입 안정성 보존을 위해 필요하다면 type casting을 넣어준다.
- 확장된 제네릭 타입에서 다형성을 보존하기 위해 bridege method를 생성한다.

#### 참고 링크
https://jyami.tistory.com/99
