# Item 17 : 변경 가능성을 최소화 하라

> 💡 불변 클래스
> : 인스턴스의 내부 값을 수정할 수 없는 클래스
> - String, BigInteger, GigDecimal, 기본타입으로 박싱된 클래스
> - 설계/구현/사용이 쉬우며 안전성이 높다

#### 1. 불변 클래스를 만들기 위한 5가지 규칙

1. 객체의 상태를 변경하는 메서드를 제공하지 않음
2. 클래스를 확장할 수 없게끔 상속을 방지
    → final로 선언하는 등 
3. 모든 필드를 final로 선언   
4. 모든 필드를 private으로 선언
   - 클라리언트에서 가변객체에 직접접근해 수정하는 일 막아줌
   - item 15, 16 참조 (접근권한을 최소화,접근자 메서드를 사용)
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없게끔 한다
   - 가변객체 참조 필드가 있다면
     - 클라이언트에서 객체 참조 X
     - getter가 그대로 참조값 반환 X
     - 생성자, 접근자, readObject에서 방어적 복사

[Example]
```java
//class를 final로 선언하여 상속 방지
public final class Complex {
    //모든 필드를 final, private으로 선언
    private final double re;
    private final double im;

    public Complex ()..중략..//생성자

    //접근자 메서드를 이용하여 방어적 복사
    public double realPart() { return re; }
    public double imaginaryPart() { return im; }

    /* <함수형 프로그래밍>
     * 피연산자에 함수를 적용 -> 결과 반환
     * 피연산자 자체는 그대로임
     */
    public Complex plus(Complex c){ // 피연산자는 그대로임 (객체의 상태를 변경하는 메서드 제공X)
        return new Complex(re + c.re, im + c.im); // 함수 적용
    }
...중략
}
```

<br/>

#### 2. 불변 객체의 장점

1. 단순하다 → 파괴될때까지 생성 시 상태를 그대로 간직
2. Thread-safe
   - 동기화 할 필요가 없으며, 동시에 여러 스레드가 사용해도 훼손 X
   - 불변객체는 안심하고 공유 가능
   > * 정적 팩토리 제공
   > : 공유 가능하기 때문에 메모리 사용량/ GC 비용 ↓ (재활용도 가능)
   > * 방어적 복사도 필요 없다
   > : clone() 복사 생성자도 필요없다 (+ String 클래스의 복사생성자 이용 말것)
3. 불변객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 가능

4. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다 : 구조가 복잡해도 불변식 유지가 수월 
   - Map의 key, Set의 원소 

5. 불변객체는 그 자체로 실패 원자성을 제공한다 
  실패 원자성 : 메서드에서 예외가 발생한 후에도 그 객체는 메서드 호출전 상태와 같은 유효한 상태를 가진다.

<br/>

#### 3. 불변 객체의 단점

1. 값이 다르면 반드시 독립된 객체로 만들어야 한다.
 : 값의 가짓수가 많으면 이를 모두 만드는데 큰 비용이 필요하다
 > 💡 백만비트 짜리 **BigInteger**에서 **비트 하나만** 바꿔야 할 때
 > 값 하나만 다른데 백만 비트짜리 인스턴스를 또 생성해야한다
 >
 > ⚡️ BitSet (가변 클래스)
 > : 원하는 비트 하나만 상수 시간안에 바꿔주는 메서드 있음 ***.flip()*** 
 
2. 원하는 객체를 완성하기 까지 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려짐

- 다단계 연산을 예측하여 기본 기능으로 제공 (각 단계마다 객체 생성 안해도 됨)
    → 다단계 연산 속도를 높여주는 가변 동반클래스를 package-private 으로 둔다
    
- 다단계 연산들이 예측이 안된다면..
→ 다단계 연산 속도를 높여주는 가변 동반클래스를 public 으로 둬서 사용
    > 🍊 **대표 예시** 
    > ***String*** 과  ***StringBuilder*** (StringBuffer는 잊어버리자)

<br />

#### 4. 불변 클래스 설계 방법

1. 상속을 막자 → final class 선언
   - 모든 생성자를 private/package-private으로 만들고 public 정적 팩토리를 제공 *(이 방법이 더 유연하다.)*
     - 어차피 public/protected 생성자가 없으니 다른 패키지에서 이 클래스를 확장하는 것이 불가능 *(사실상 final class인 셈)*

2. 재정의하게 설계가 되어있다면 ...(ex. BigInteger)
 - 인수로 받은 객체가 '진짜'인지 확인하고, 이 인수들은 가변으로 가정하고 **방어적으로 복사**해서 사용해야한다.

3. 불변 객체 기준 완화
> 성능을 위해 완화
> : "어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다."

- 계산 비용이 큰 값을 나중에 계산하여 final 이 아닌 필드에 캐싱해둔다
**ex)** String 클래스 = 불변객체지만, final이 아닌 필드에 hash로 캐시, hashcode 재 연산 비용을 감축


-----

<br/>

##### 🍊 QUIZ 

1. getter와 함께 setter를 만들자 [ O | X ]
2. 다단계 연산이 많고, 성능을 높여주기 위해 불변 클래스와 쌍을 이루는 [　　　　]를 제공하자.
3. 불변클래스 설계시, 생성자를 private로 하고 public 정적 팩토리를 제공하는 것보다 final class로 선언하는 것이 더 유연성이 높다. [ O | X ]
4. 모든 필드는 private final인 것이 좋다. [ O | X ]
5. 객체 생성 후 불변식 설정을 진행한다 [ O | X ]
