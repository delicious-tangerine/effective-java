# Item 20 : 추상 클래스보다는 인터페이스를 우선하라


#### 1. Interface와 추상클래스

##### 공통점
: 두 매커니즘 모두 인스턴스 메서드를 구현 형태로 제공 가능

##### 차이점


|인터페이스|추상클래스|
|----|----|
|인터페이스가 *선언한 메서드를 모두 정의*하고, 해당 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 **같은 타입**|추상클래스가 정의한 타입을 *구현하는 클래스*는 반드시 **추상클래스의 하위클래스** *(자바는 단일 상속만 지원해서 이 방식은 새로운 타입을 정의하는 데 제약)*|
|기존 클래스에도 **손쉽게** 새로운 인터페이스를 구현해 넣을 수 있음|기존 클래스 위에 새 추상 클래스를 끼워넣기는 **어려움**|
|믹스인에 안성맞춤 : 유연성 |기존 클래스에 덧씌울 수 없고, **두 부모를 섬길 수 없기에 믹스인 정의 불가** → 고도비만 계층구조가 만들어진 것 **[조합폭발]**|
|**계층구조가 없는** 타입 프레임워크를 만들 수 있다 (ex. SingerSongWriter|추상클래스에서 두 클래스가 같은 추상 클래스(=공통조상)를 확장 → 새로 **추가된 추상 클래스의 모든 자손이 이를 상속**|

#### 2. 믹스인(mixin) 과 디폴트 메서드

[1] 믹스인(mixin)
- 클래스가 구현할 수 있는 타입의 주된기능에 선택적 기능을 혼합(mixed in)한다
- 믹스인 인터페이스를 구현한 클래스에 원래의 **주된타입**외에도 **특정 선택적 행위**를 제공한다고 선언하는 효과
- ex) Comparable : 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언

[2] 디폴트 메서드
- 인터페이스 메서드 중 구현방법이 명백한 것을 디폴트 메서드로 제공
- 제공시, @implSpec 자바독 태그를 붙여 문서화 해야함
> 💡 디폴트 메서드의 제약사항
> 많은 인터페이스가 equals와 hashCode등의 Object의 메서드를 정의 하고 있지만, 이를 디폴트 메서드로 제공해선 안됨
> 인터페이스는 인스턴트 필드/public이 아닌 정적 멤버도 가질 수 었다
> 만들지 않은 인터페이스에는 디폴트 메서드를 추가 불가


#### 3. 추상 골격 구현 (skeletal implementation)

: 인터페이스와 추상 골격 구현 클래스를 함께 제공하면 두 분야의 장점을 모두 취한다

[1] 추상 골격 구현 클래스란
- 인터페이스로 :타입 정의 + 필요시 디폴트 메서드 몇개도 함께 제공
- 추상 골격 구현 클래스 : 나머지 메서드들까지 구현 
  - 단순히 골격 구현을 확장하는 것만으로 이 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다
- ##### 템플릿 메서드 패턴
- 컬렉션 프레임워크의 AbstractList, AbstractSet, AbstractMap 클래스 => 핵심 컬렉션 인터페이스의 골격 구현

[골격 구현을 사용해 완성한 구체 클래스]
```java
//완벽히 동작하는 List 구현체를 반환하는 정적 팩터리 메서드
static List<Integer> intArrayAsList(int[] a){
    Objects.requiredNull(a); 

    //다이아몬드 연산자는 자바9부터
    // int배열을 받아 Integer 인스턴스의 리스트 형태로 보여줌 >> 어탭터
    return new AbstractList<>(){
        @Override
        public Integer get(int i){
            return a[i];//오토박싱
        }
        @Override
        public Integer set(int i, Integer val){
            int oldVal = a[i];
            a[i] = val ;//오토언박싱
            return oldVal; //오토박싱
        //박싱과 언박싱 (int/Integer 인스턴스 사이의 변환) : 성능은 좋지 않음
        @Override
        public int size() {
            return a.length;
        }
    }
}

```
[장점]
- 골격 구현 클래스는 추상클래스처럼 **구현을 도와주는** 동시에, 추상 클래스 정의 시 따라오는 **제약사항에서 자유로움**
- 골격 구현을 확장하면서 인터페이스 구현이 거의 끝남(골격 구현을 확장하지 못하는 구조라면 인터페이스를 직접 구현)
  - 인터페이스가 직접 제공하는 디폴트 메서드의 이점을 사용가능
- 래퍼 클래스와 비슷한 방식을 사용 : 골격 구현 클래스를 우회적으로 이용 가능
  - 인터페이스를 구현한 클래스에서 해당 **골격 구현을 확장한 private내부 클래스를 정의**
  - **각 메서드 호출**을 내부 클래스의 인스턴스에 *전달*
  > 래퍼 클래스와 비슷한 이 방식을 시뮬레이트한 ***다중상속***

[2] 추상 골격 구현 작성법
- 다른 메서드들의 구현에 사용되는 **기반 메서드들을 선정** → 골격 구현에서는 추상 메서드가 될 것
- 기반 메서드들을 사용해 **직접 구현할 수 있는 메서드**를 모두 **디폴트 메서드**로 제공
- 인터페이스의 메서드 모두가 기반메서드+디폴트 메서드 라면, 골격 구현 클래스를 별도로 만들 이유는 없다
  - 위 두개로 만들지 못한 메서드가 남아있을 경우, 해당 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 작성
  - 골격 구현 클래스에는 필요하면 public이 아닌 필드와 메서드를 추가

[3] 단순 구현 (simple implementation)
- 골격 구현의 작은 변종
- 상속을 위해 인터페이스를 구현한 것이 골격 구현과 공통점이지만, 추상클래스가 아니다.
- AbstractMap.SimpleEntry가 좋은 예



구조상 골격 후현을 확장하지 못하는 처지라 인터페이스를 직접 구현

1.  equals와 hashCode등의 Object의 메서드를 디폴트 메서드로 제공한다 [ O | X ]
2. 상속을 금지하려면 클래스를 [　　　　](으)로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만든다.
3. 인터페이스의 메서드 모두가 기반메서드+디폴트 메서드 라면, 골격 구현 클래스를 별도로 만들 이유는 없다[ O | X ]